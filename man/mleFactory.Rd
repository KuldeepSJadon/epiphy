% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/distr-fitting.R
\name{mleFactory}
\alias{mleFactory}
\alias{mleBetabinom}
\alias{mleNbinom}
\title{Factory for Maximum Likelihood Estimation (MLE) functions}
\usage{
mleFactory(.negLogLik, .data, .start, .preEstimate = NULL, ...)

mleBetabinom(data, start, ...)

mleNbinom(data, start, ...)
}
\arguments{
\item{.negLogLik}{Negative log-likelihood function.}

\item{.data}{Data set to work with. Must be a named list (A data frame is a
named list.)}

\item{.start}{Starting values for the parameters of interest. Must be a named
list.}

\item{.preEstimate}{Function to get initial values to work with. Could be a
function computing the parameters specified in \code{.start} based on
method of moment estimation (MME).}

\item{...}{Extra parameters which will becomes default parameters for the
created function.}
}
\description{
Creates functions with the signature \code{function(data, start, ...)} in
order to performe maximum likelihood estimation. It's based on the
\code{\link[bbmle]{mle2}} (package \code{bbmle}) function to perform the
optimization. The default optimizer handle by \code{mle2} is the built-in
\code{optim}, but other optimizer are possible (see \code{mle2} documentation
for more details).
}
\details{
Two functions are already implemented for convenience reasons: \code{mleBetabinom} and
\code{mleNbinom}. But, using the tool \code{fitDiffDistr}, one should not handle such
functions. Nevertheless, it should be usefull if you want to use an alternative
function for the aggregation case inside the \code{fitDiffDistr} function.
}
\examples{
rand <- glm(d/n ~ 1, family = binomial, data = dataMadden1987, weights = n)
p <- estimateCoef(rand, quote(1/(1+exp(-x1))))
# p <- estimateCoef(rand, quote(logistic(x1)))
params <- rbind(coef(summary(rand)), unlist(p))
rownames(params) <- c("logit(p)", "p")
printCoefmat(params)


agg <- mleBetabinom(data = dataMadden1987, lower = list(alpha = -Inf, beta = -Inf))
# coef(summary(agg))

# to compute p, one can use the function estimateCoef
# see ?estimateCoef for more information
p     <- estimateCoef(agg, quote(x1 / (x1 + x2)), student = FALSE)
theta <- estimateCoef(agg, quote(1  / (x1 + x2)), student = FALSE)
rho   <- estimateCoef(agg, quote(1  / (x1 + x2 + 1)), student = FALSE)
params <- rbind(coef(summary(agg)), unlist(p), unlist(theta), unlist(rho))
rownames(params) <- c("alpha", "beta", "p", "theta", "rho")
printCoefmat(params)

# Computing agg, is the same as doing the following hard way :
agg2 <- mleFactory(
    .negLogLik = function(d, n, alpha, beta) {
        sum(-dbetabinom(x = d, size = n, shape1 = alpha, shape2 = beta,
        log = TRUE)) },
    .data = c("d", "n"),
    .start = c("alpha", "beta"),
    .preEstimate = epiphy:::mmeBetabinom,
    method = "L-BFGS-B",
    lower = c(alpha = 1e-7, beta = 1e-7))
agg2 <- agg2(data = dataMadden1987)
coef(summary(agg2))

}
\seealso{
fitDiffDistr
}
